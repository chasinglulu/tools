From 03040a420916761b00624f1d51f19c3ded4f6b0c Mon Sep 17 00:00:00 2001
From: Charleye <wangkart@aliyun.com>
Date: Mon, 8 May 2023 14:36:40 +0800
Subject: [PATCH 1/2] arm: sigi-partition: Add initial partition development

---
 hw/arm/hobot-versal-virt-partition.c   | 779 +++++++++++++++++++++++++
 hw/arm/meson.build                     |   1 +
 hw/arm/versal-sigi-partition.c         | 631 ++++++++++++++++++++
 include/hw/arm/versal-sigi-partition.h | 170 ++++++
 4 files changed, 1581 insertions(+)
 create mode 100644 hw/arm/hobot-versal-virt-partition.c
 create mode 100644 hw/arm/versal-sigi-partition.c
 create mode 100644 include/hw/arm/versal-sigi-partition.h

diff --git a/hw/arm/hobot-versal-virt-partition.c b/hw/arm/hobot-versal-virt-partition.c
new file mode 100644
index 0000000000..258a4e7338
--- /dev/null
+++ b/hw/arm/hobot-versal-virt-partition.c
@@ -0,0 +1,779 @@
+/*
+ * Horizon Robotics Jounery SoC emulation
+ *
+ * Copyright (C) 2023 Horizon Robotics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/error-report.h"
+#include "qapi/error.h"
+#include "sysemu/device_tree.h"
+#include "hw/boards.h"
+#include "hw/sysbus.h"
+#include "hw/arm/fdt.h"
+#include "cpu.h"
+#include "hw/qdev-properties.h"
+#include "hw/arm/versal-sigi.h"
+#include "qom/object.h"
+#include "sysemu/sysemu.h"
+#include "qemu/log.h"
+
+#define TYPE_HOBOT_VERSAL_VIRT_MACHINE MACHINE_TYPE_NAME("hobot-sigi-virt.part")
+OBJECT_DECLARE_SIMPLE_TYPE(HobotVersalVirt, HOBOT_VERSAL_VIRT_MACHINE)
+
+struct HobotVersalVirt {
+    MachineState parent_obj;
+    Notifier machine_done;
+
+    SigiVirt soc;
+
+    void *fdt;
+    int fdt_size;
+    uint32_t clock_phandle;
+    uint32_t gic_phandle;
+    uint32_t msi_phandle;
+    int psci_conduit;
+    struct arm_boot_info bootinfo;
+
+    struct {
+        bool virt;
+        bool secure;
+        bool has_emmc;
+    } cfg;
+};
+
+static void hobot_versal_virt_set_emmc(Object *obj, bool value, Error **errp)
+{
+    HobotVersalVirt *s = HOBOT_VERSAL_VIRT_MACHINE(obj);
+
+    s->cfg.has_emmc = value;
+}
+
+static void hobot_versal_virt_set_virt(Object *obj, bool value, Error **errp)
+{
+    HobotVersalVirt *s = HOBOT_VERSAL_VIRT_MACHINE(obj);
+
+    s->cfg.virt = value;
+}
+
+static void hobot_versal_virt_set_secure(Object *obj, bool value, Error **errp)
+{
+    HobotVersalVirt *s = HOBOT_VERSAL_VIRT_MACHINE(obj);
+
+    s->cfg.secure = value;
+}
+
+static const CPUArchIdList *virt_possible_cpu_arch_ids(MachineState *ms)
+{
+    int n;
+    unsigned int max_cpus = ms->smp.max_cpus;
+    HobotVersalVirt *vms = HOBOT_VERSAL_VIRT_MACHINE(ms);
+    MachineClass *mc = MACHINE_GET_CLASS(vms);
+
+    if (ms->possible_cpus) {
+        assert(ms->possible_cpus->len == max_cpus);
+        return ms->possible_cpus;
+    }
+
+    ms->possible_cpus = g_malloc0(sizeof(CPUArchIdList) +
+                                  sizeof(CPUArchId) * max_cpus);
+    ms->possible_cpus->len = max_cpus;
+    for (n = 0; n < ms->possible_cpus->len; n++) {
+        ms->possible_cpus->cpus[n].type = ms->cpu_type;
+        ms->possible_cpus->cpus[n].arch_id =
+            virt_cpu_mp_affinity(n);
+
+        assert(!mc->smp_props.dies_supported);
+        ms->possible_cpus->cpus[n].props.has_socket_id = true;
+        ms->possible_cpus->cpus[n].props.socket_id =
+            n / (ms->smp.clusters * ms->smp.cores * ms->smp.threads);
+        ms->possible_cpus->cpus[n].props.has_cluster_id = true;
+        ms->possible_cpus->cpus[n].props.cluster_id =
+            (n / (ms->smp.cores * ms->smp.threads)) % ms->smp.clusters;
+        ms->possible_cpus->cpus[n].props.has_core_id = true;
+        ms->possible_cpus->cpus[n].props.core_id =
+            (n / ms->smp.threads) % ms->smp.cores;
+        ms->possible_cpus->cpus[n].props.has_thread_id = true;
+        ms->possible_cpus->cpus[n].props.thread_id =
+            n % ms->smp.threads;
+    }
+    return ms->possible_cpus;
+}
+
+static void create_fdt(HobotVersalVirt *s)
+{
+    MachineClass *mc = MACHINE_GET_CLASS(s);
+
+    s->fdt = create_device_tree(&s->fdt_size);
+    if (!s->fdt) {
+        error_report("create_device_tree() failed");
+        exit(1);
+    }
+
+    /* Allocate all phandles.  */
+    s->gic_phandle = qemu_fdt_alloc_phandle(s->fdt);
+    s->clock_phandle = qemu_fdt_alloc_phandle(s->fdt);
+
+    /* Create /chosen node for load_dtb.  */
+    qemu_fdt_add_subnode(s->fdt, "/chosen");
+
+    /* Create /soc node for load_dtb. */
+    qemu_fdt_add_subnode(s->fdt, "/soc");
+    qemu_fdt_setprop(s->fdt, "/soc", "ranges", NULL, 0);
+    qemu_fdt_setprop_cell(s->fdt, "/soc", "#size-cells", 0x2);
+    qemu_fdt_setprop_cell(s->fdt, "/soc", "#address-cells", 0x2);
+    qemu_fdt_setprop_string(s->fdt, "/soc", "compatible", "simple-bus");
+
+    /* Header */
+    qemu_fdt_setprop_cell(s->fdt, "/", "interrupt-parent", s->gic_phandle);
+    qemu_fdt_setprop_cell(s->fdt, "/", "#size-cells", 0x2);
+    qemu_fdt_setprop_cell(s->fdt, "/", "#address-cells", 0x2);
+    qemu_fdt_setprop_string(s->fdt, "/", "model", mc->desc);
+    qemu_fdt_setprop_string(s->fdt, "/", "compatible", "hobot-versal-virt");
+}
+
+static void fdt_add_timer_nodes(const HobotVersalVirt *vms)
+{
+    uint32_t irqflags = GIC_FDT_IRQ_FLAGS_LEVEL_HI;
+    const char compat[] = "arm,armv8-timer";
+
+    qemu_fdt_add_subnode(vms->fdt, "/timer");
+    qemu_fdt_setprop(vms->fdt, "/timer", "compatible",
+                        compat, sizeof(compat));
+
+    qemu_fdt_setprop(vms->fdt, "/timer", "always-on", NULL, 0);
+    qemu_fdt_setprop_cells(vms->fdt, "/timer", "interrupts",
+                       GIC_FDT_IRQ_TYPE_PPI, ARCH_TIMER_S_EL1_IRQ, irqflags,
+                       GIC_FDT_IRQ_TYPE_PPI, ARCH_TIMER_NS_EL1_IRQ, irqflags,
+                       GIC_FDT_IRQ_TYPE_PPI, ARCH_TIMER_VIRT_IRQ, irqflags,
+                       GIC_FDT_IRQ_TYPE_PPI, ARCH_TIMER_NS_EL2_IRQ, irqflags);
+}
+
+static void fdt_add_cpu_nodes(const HobotVersalVirt *vms)
+{
+    int cpu;
+    int addr_cells = 1;
+    MachineState *ms = MACHINE(vms);
+    MachineClass *mc = MACHINE_GET_CLASS(ms);
+    int smp_cpus = ms->smp.cpus;
+
+    mc->possible_cpu_arch_ids(ms);
+    /*
+     * See Linux Documentation/devicetree/bindings/arm/cpus.yaml
+     * On ARM v8 64-bit systems value should be set to 2,
+     * that corresponds to the MPIDR_EL1 register size.
+     * If MPIDR_EL1[63:32] value is equal to 0 on all CPUs
+     * in the system, #address-cells can be set to 1, since
+     * MPIDR_EL1[63:32] bits are not used for CPUs
+     * identification.
+     *
+     * Here we actually don't know whether our system is 32- or 64-bit one.
+     * The simplest way to go is to examine affinity IDs of all our CPUs. If
+     * at least one of them has Aff3 populated, we set #address-cells to 2.
+     */
+    for (cpu = 0; cpu < smp_cpus; cpu++) {
+        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(cpu));
+
+        if (armcpu->mp_affinity & ARM_AFF3_MASK) {
+            addr_cells = 2;
+            break;
+        }
+    }
+
+    qemu_fdt_add_subnode(vms->fdt, "/cpus");
+
+    qemu_fdt_setprop_cell(vms->fdt, "/cpus", "#address-cells", addr_cells);
+    qemu_fdt_setprop_cell(vms->fdt, "/cpus", "#size-cells", 0x0);
+
+    for (cpu = smp_cpus - 1; cpu >= 0; cpu--) {
+        char *nodename = g_strdup_printf("/cpus/cpu@%lx", ms->possible_cpus->cpus[cpu].arch_id);
+        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(cpu));
+        CPUState *cs = CPU(armcpu);
+
+        qemu_fdt_add_subnode(vms->fdt, nodename);
+        qemu_fdt_setprop_string(vms->fdt, nodename, "device_type", "cpu");
+        qemu_fdt_setprop_string(vms->fdt, nodename, "compatible",
+                                    armcpu->dtb_compatible);
+
+        if (vms->psci_conduit != QEMU_PSCI_CONDUIT_DISABLED && smp_cpus > 1) {
+            qemu_fdt_setprop_string(vms->fdt, nodename,
+                                        "enable-method", "psci");
+        }
+
+        if (addr_cells == 2) {
+            qemu_fdt_setprop_u64(vms->fdt, nodename, "reg",
+                                 armcpu->mp_affinity);
+        } else {
+            qemu_fdt_setprop_cell(vms->fdt, nodename, "reg",
+                                  armcpu->mp_affinity);
+        }
+
+        if (ms->possible_cpus->cpus[cs->cpu_index].props.has_node_id) {
+            qemu_fdt_setprop_cell(vms->fdt, nodename, "numa-node-id",
+                ms->possible_cpus->cpus[cs->cpu_index].props.node_id);
+        }
+
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "phandle",
+                                  qemu_fdt_alloc_phandle(vms->fdt));
+
+        g_free(nodename);
+    }
+
+    /*
+     * Add vCPU topology description through fdt node cpu-map.
+     *
+     * See Linux Documentation/devicetree/bindings/cpu/cpu-topology.txt
+     * In a SMP system, the hierarchy of CPUs can be defined through
+     * four entities that are used to describe the layout of CPUs in
+     * the system: socket/cluster/core/thread.
+     *
+     * A socket node represents the boundary of system physical package
+     * and its child nodes must be one or more cluster nodes. A system
+     * can contain several layers of clustering within a single physical
+     * package and cluster nodes can be contained in parent cluster nodes.
+     *
+     * Note: currently we only support one layer of clustering within
+     * each physical package.
+    */
+    qemu_fdt_add_subnode(vms->fdt, "/cpus/cpu-map");
+
+    for (cpu = smp_cpus - 1; cpu >= 0; cpu--) {
+        char *cpu_path = g_strdup_printf("/cpus/cpu@%lx",
+                                ms->possible_cpus->cpus[cpu].arch_id);
+        char *map_path;
+
+        if (ms->smp.threads > 1) {
+            map_path = g_strdup_printf(
+                "/cpus/cpu-map/socket%d/cluster%d/core%d/thread%d",
+                cpu / (ms->smp.clusters * ms->smp.cores * ms->smp.threads),
+                (cpu / (ms->smp.cores * ms->smp.threads)) % ms->smp.clusters,
+                (cpu / ms->smp.threads) % ms->smp.cores,
+                cpu % ms->smp.threads);
+        } else {
+            map_path = g_strdup_printf(
+                "/cpus/cpu-map/socket%d/cluster%d/core%d",
+                cpu / (ms->smp.clusters * ms->smp.cores),
+                (cpu / ms->smp.cores) % ms->smp.clusters,
+                cpu % ms->smp.cores);
+        }
+        qemu_fdt_add_path(vms->fdt, map_path);
+        qemu_fdt_setprop_phandle(vms->fdt, map_path, "cpu", cpu_path);
+
+        g_free(map_path);
+        g_free(cpu_path);
+    }
+}
+
+static void create_pcie_irq_map(const HobotVersalVirt *vms,
+                                uint32_t gic_phandle,
+                                int first_irq, const char *nodename)
+{
+    int devfn, pin;
+    uint32_t full_irq_map[4 * 4 * 10] = { 0 };
+    uint32_t *irq_map = full_irq_map;
+
+    for (devfn = 0; devfn <= 0x18; devfn += 0x8) {
+        for (pin = 0; pin < 4; pin++) {
+            int irq_type = GIC_FDT_IRQ_TYPE_SPI;
+            int irq_nr = first_irq + ((pin + PCI_SLOT(devfn)) % PCI_NUM_PINS);
+            int irq_level = GIC_FDT_IRQ_FLAGS_LEVEL_HI;
+            int i;
+
+            uint32_t map[] = {
+                devfn << 8, 0, 0,                           /* devfn */
+                pin + 1,                                    /* PCI pin */
+                gic_phandle, 0, 0, irq_type, irq_nr, irq_level }; /* GIC irq */
+
+            /* Convert map to big endian */
+            for (i = 0; i < 10; i++) {
+                irq_map[i] = cpu_to_be32(map[i]);
+            }
+            irq_map += 10;
+        }
+    }
+
+    qemu_fdt_setprop(vms->fdt, nodename, "interrupt-map",
+                     full_irq_map, sizeof(full_irq_map));
+
+    qemu_fdt_setprop_cells(vms->fdt, nodename, "interrupt-map-mask",
+                           cpu_to_be16(PCI_DEVFN(3, 0)), /* Slot 3 */
+                           0, 0,
+                           0x7           /* PCI irq */);
+}
+
+static void fdt_add_pcie_node(HobotVersalVirt *vms, int pcie)
+{
+    char *nodename;
+    hwaddr base = base_memmap[pcie].base;
+    hwaddr size = base_memmap[pcie].size;
+    int irq = a78irqmap[pcie];
+    int nr_pcie_buses = size / PCIE_MMCFG_SIZE_MIN;
+
+    nodename = g_strdup_printf("/soc/pcie@%" PRIx64, base);
+    qemu_fdt_add_subnode(vms->fdt, nodename);
+    qemu_fdt_setprop_string(vms->fdt, nodename,
+                            "compatible", "pci-host-ecam-generic");
+    qemu_fdt_setprop_string(vms->fdt, nodename, "device_type", "pci");
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "#address-cells", 3);
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "#size-cells", 2);
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "linux,pci-domain", 0);
+    qemu_fdt_setprop_cells(vms->fdt, nodename, "bus-range", 0,
+                           nr_pcie_buses - 1);
+    qemu_fdt_setprop(vms->fdt, nodename, "dma-coherent", NULL, 0);
+
+    if (vms->msi_phandle) {
+        qemu_fdt_setprop_cells(vms->fdt, nodename, "msi-parent",
+                               vms->msi_phandle);
+    }
+
+    qemu_fdt_setprop_sized_cells(vms->fdt, nodename, "reg", 2, base, 2, size);
+
+    qemu_fdt_setprop_sized_cells(vms->fdt, nodename, "ranges",
+                                     1, FDT_PCI_RANGE_MMIO, 2, base_memmap[VIRT_PCIE_MMIO].base,
+                                     2, base_memmap[VIRT_PCIE_MMIO].base,
+                                     2, base_memmap[VIRT_PCIE_MMIO].size,
+                                     1, FDT_PCI_RANGE_MMIO_64BIT,
+                                     2, base_memmap[VIRT_PCIE_MMIO_HIGH].base,
+                                     2, base_memmap[VIRT_PCIE_MMIO_HIGH].base,
+                                     2, base_memmap[VIRT_PCIE_MMIO_HIGH].base);
+
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "#interrupt-cells", 1);
+    create_pcie_irq_map(vms, vms->gic_phandle, irq, nodename);
+}
+
+static void fdt_add_gic_node(HobotVersalVirt *vms)
+{
+    char *nodename;
+
+    vms->gic_phandle = qemu_fdt_alloc_phandle(vms->fdt);
+    qemu_fdt_setprop_cell(vms->fdt, "/", "interrupt-parent", vms->gic_phandle);
+
+    nodename = g_strdup_printf("/gic@%" PRIx64,
+                               base_memmap[VIRT_GIC_DIST].base);
+    qemu_fdt_add_subnode(vms->fdt, nodename);
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "#interrupt-cells", 3);
+    qemu_fdt_setprop(vms->fdt, nodename, "interrupt-controller", NULL, 0);
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "#address-cells", 0x2);
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "#size-cells", 0x2);
+    qemu_fdt_setprop(vms->fdt, nodename, "ranges", NULL, 0);
+    qemu_fdt_setprop_string(vms->fdt, nodename, "compatible",
+                            "arm,gic-v3");
+    qemu_fdt_setprop_cell(vms->fdt, nodename,
+                            "#redistributor-regions", 1);
+    qemu_fdt_setprop_sized_cells(vms->fdt, nodename, "reg",
+                                    2, base_memmap[VIRT_GIC_DIST].base,
+                                    2, base_memmap[VIRT_GIC_DIST].size,
+                                    2, base_memmap[VIRT_GIC_REDIST].base,
+                                    2, base_memmap[VIRT_GIC_REDIST].size);
+
+    if (vms->cfg.virt) {
+        qemu_fdt_setprop_cells(vms->fdt, nodename, "interrupts",
+                                GIC_FDT_IRQ_TYPE_PPI, ARCH_GIC_MAINT_IRQ,
+                                GIC_FDT_IRQ_FLAGS_LEVEL_HI);
+    }
+
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "phandle", vms->gic_phandle);
+    g_free(nodename);
+}
+
+static void fdt_add_gic_its_node(HobotVersalVirt *vms)
+{
+    char *nodename;
+
+    vms->msi_phandle = qemu_fdt_alloc_phandle(vms->fdt);
+    nodename = g_strdup_printf("/gic@%" PRIx64 "/its@%" PRIx64,
+                                base_memmap[VIRT_GIC_DIST].base,
+                                base_memmap[VIRT_GIC_ITS].base);
+    qemu_fdt_add_subnode(vms->fdt, nodename);
+    qemu_fdt_setprop_string(vms->fdt, nodename, "compatible",
+                            "arm,gic-v3-its");
+    qemu_fdt_setprop(vms->fdt, nodename, "msi-controller", NULL, 0);
+    qemu_fdt_setprop_sized_cells(vms->fdt, nodename, "reg",
+                                2, base_memmap[VIRT_GIC_ITS].base,
+                                2, base_memmap[VIRT_GIC_ITS].size);
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "phandle", vms->msi_phandle);
+    g_free(nodename);
+}
+
+static void fdt_add_clk_nodes(HobotVersalVirt *vms)
+{
+    /* Clock node, for the benefit of the UART. The kernel device tree
+     * binding documentation claims the uart node clock properties are
+     * optional.
+     */
+    vms->clock_phandle = qemu_fdt_alloc_phandle(vms->fdt);
+    qemu_fdt_add_subnode(vms->fdt, "/apb-pclk");
+    qemu_fdt_setprop_string(vms->fdt, "/apb-pclk", "compatible", "fixed-clock");
+    qemu_fdt_setprop_cell(vms->fdt, "/apb-pclk", "#clock-cells", 0x0);
+    qemu_fdt_setprop_cell(vms->fdt, "/apb-pclk", "clock-frequency", 24000000);
+    qemu_fdt_setprop_string(vms->fdt, "/apb-pclk", "clock-output-names",
+                                "clk24mhz");
+    qemu_fdt_setprop_cell(vms->fdt, "/apb-pclk", "phandle", vms->clock_phandle);
+}
+
+static void fdt_add_aliases_nodes(HobotVersalVirt *vms)
+{
+    int i;
+    hwaddr base = base_memmap[VIRT_UART].base;
+    hwaddr size = base_memmap[VIRT_UART].size;
+    qemu_fdt_add_subnode(vms->fdt, "/aliases");
+    char *nodename, *propname;
+
+    for (i = 0; i < ARRAY_SIZE(vms->soc.apu.peri.uarts); i++) {
+        nodename = g_strdup_printf("/serial@%" PRIx64, base);
+        propname = g_strdup_printf("serial%d", i);
+        qemu_fdt_setprop_string(vms->fdt, "/aliases", propname, nodename);
+
+        base += size;
+
+        g_free(nodename);
+        g_free(propname);
+    }
+}
+
+static void fdt_add_usb_nodes(const HobotVersalVirt *vms)
+{
+    char *nodename;
+    hwaddr ctrl_base = base_memmap[VIRT_USB_CTRL].base;
+    hwaddr ctrl_size = base_memmap[VIRT_USB_CTRL].size;
+    hwaddr base = base_memmap[VIRT_DWC_USB].base;
+    hwaddr size = base_memmap[VIRT_DWC_USB].size;
+    int irq = a78irqmap[VIRT_DWC_USB];
+    const char ctrl_compat[] = "hobot,sigi-dwc3";
+    const char compat[] = "snps,dwc3";
+
+    nodename = g_strdup_printf("/soc/usb@%" PRIx64, ctrl_base);
+    qemu_fdt_add_subnode(vms->fdt, nodename);
+    qemu_fdt_setprop(vms->fdt, nodename, "compatible",
+                            ctrl_compat, sizeof(ctrl_compat));
+    qemu_fdt_setprop_sized_cells(vms->fdt, nodename, "reg",
+                                2, ctrl_base, 2, ctrl_size);
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "#address-cells", 2);
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "#size-cells", 2);
+    qemu_fdt_setprop(vms->fdt, nodename, "ranges", NULL, 0);
+    g_free(nodename);
+
+
+    nodename = g_strdup_printf("/soc/usb@%" PRIx64 "/dwc_usb@%" PRIx64, ctrl_base, base);
+    qemu_fdt_add_subnode(vms->fdt, nodename);
+    qemu_fdt_setprop(vms->fdt, nodename, "compatible",
+                            compat, sizeof(compat));
+    qemu_fdt_setprop_sized_cells(vms->fdt, nodename, "reg",
+                                2, base, 2, size);
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "#stream-id-cells", 1);
+    qemu_fdt_setprop_cells(vms->fdt, nodename, "interrupts",
+                                GIC_FDT_IRQ_TYPE_SPI, irq,
+                                GIC_FDT_IRQ_FLAGS_LEVEL_HI);
+    qemu_fdt_setprop_string(vms->fdt, nodename, "interrupt-names", "dwc_usb3");
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "snps,quirk-frame-length-adjustment", 0x20);
+    qemu_fdt_setprop(vms->fdt, nodename, "snps,refclk_fladj", NULL, 0);
+    qemu_fdt_setprop(vms->fdt, nodename, "snps,enable_guctl1_resume_quirk", NULL, 0);
+    qemu_fdt_setprop(vms->fdt, nodename, "snps,enable_guctl1_ipd_quirk", NULL, 0);
+    qemu_fdt_setprop(vms->fdt, nodename, "snps,xhci-stream-quirk", NULL, 0);
+    qemu_fdt_setprop_string(vms->fdt, nodename, "dr_mode", "host");
+    qemu_fdt_setprop_string(vms->fdt, nodename, "phy-names", "usb3-phy");
+    g_free(nodename);
+}
+
+static void fdt_add_gpio_nodes(const HobotVersalVirt *vms, int gpio)
+{
+    char *nodename, *portname, *bankname;
+    hwaddr base = base_memmap[gpio].base;
+    hwaddr size = base_memmap[gpio].size;
+    int irq = a78irqmap[gpio];
+    const char compat[] = "snps,dw-apb-gpio";
+    const char port_compat[] = "snps,dw-apb-gpio-port";
+    int i, j;
+
+    for (i = 0; i < ARRAY_SIZE(vms->soc.apu.peri.gpio); i++) {
+        nodename = g_strdup_printf("/soc/gpio@%" PRIx64, base);
+        qemu_fdt_add_subnode(vms->fdt, nodename);
+        qemu_fdt_setprop(vms->fdt, nodename, "compatible",
+                            compat, sizeof(compat));
+        qemu_fdt_setprop_sized_cells(vms->fdt, nodename, "reg",
+                                        2, base, 2, size);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "#address-cells", 1);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "#size-cells", 0);
+
+        /* 4 port bank per gpio controller */
+        for (j = 0; j < 4; j++) {
+            portname = g_strdup_printf("/gpio@%" PRIx64 "/port@%d", base, j);
+            bankname = g_strdup_printf("gpio%d_%c", i, 'a' + j);
+            qemu_fdt_add_path(vms->fdt, portname);
+            qemu_fdt_setprop(vms->fdt, portname, "compatible",
+                                port_compat, sizeof(port_compat));
+            qemu_fdt_setprop(vms->fdt, portname, "gpio-controller", NULL, 0);
+            qemu_fdt_setprop_cell(vms->fdt, portname, "#gpio-cells", 2);
+            qemu_fdt_setprop_cell(vms->fdt, portname, "snps,nr-gpios", 32);
+            qemu_fdt_setprop_sized_cells(vms->fdt, portname, "reg",1, j);
+            qemu_fdt_setprop_string(vms->fdt, portname, "bank-name", bankname);
+
+            /* GPIO port A as interrupt */
+            if (j == 0) {
+                qemu_fdt_setprop(vms->fdt, portname, "interrupt-controller", NULL, 0);
+                qemu_fdt_setprop_cell(vms->fdt, portname, "#interrupt-cells", 2);
+                qemu_fdt_setprop_cells(vms->fdt, portname, "interrupts",
+                                            GIC_FDT_IRQ_TYPE_SPI, irq,
+                                            GIC_FDT_IRQ_FLAGS_LEVEL_HI);
+            }
+
+            g_free(bankname);
+            g_free(portname);
+        }
+
+        base += size;
+        irq++;
+        g_free(nodename);
+    }
+}
+
+static void fdt_add_sdhci_nodes(const HobotVersalVirt *vms, int sdhci)
+{
+    char *nodename;
+    uint32_t nr_sdhci = ARRAY_SIZE(vms->soc.apu.peri.mmc);
+    hwaddr base = base_memmap[sdhci].base;
+    hwaddr size = base_memmap[sdhci].size;
+    int irq = a78irqmap[sdhci];
+    const char compat[] = "cdns,sd4hc";
+    int i;
+
+    /* Create nodes in incremental address */
+    base = base + size * (nr_sdhci - 1);
+    irq = irq + 2 * (nr_sdhci - 1);
+    for (i = nr_sdhci - 1; i >= 0; i--) {
+        nodename = g_strdup_printf("/soc/sdhci@%" PRIx64, base);
+        qemu_fdt_add_subnode(vms->fdt, nodename);
+        /* Note that we can't use setprop_string because of the embedded NUL */
+        qemu_fdt_setprop(vms->fdt, nodename, "compatible",
+                            compat, sizeof(compat));
+        qemu_fdt_setprop_sized_cells(vms->fdt, nodename, "reg",
+                                        2, base, 2, size);
+        qemu_fdt_setprop_cells(vms->fdt, nodename, "interrupts",
+                                GIC_FDT_IRQ_TYPE_SPI, irq,
+                                GIC_FDT_IRQ_FLAGS_LEVEL_HI);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "clocks", vms->clock_phandle);
+        qemu_fdt_setprop_cells(vms->fdt, nodename, "sdhci-caps-mask", 0xffffffff, 0xffffffff);
+        qemu_fdt_setprop_cells(vms->fdt, nodename, "sdhci-caps", 0x70, 0x156ac800);
+
+        if (vms->cfg.has_emmc && i == 0) {
+            qemu_fdt_setprop(vms->fdt, nodename, "non-removable", NULL, 0);
+            qemu_fdt_setprop(vms->fdt, nodename, "no-sdio", NULL, 0);
+            qemu_fdt_setprop(vms->fdt, nodename, "no-sd", NULL, 0);
+            qemu_fdt_setprop_cell(vms->fdt, nodename, "bus-width", 8);
+            qemu_fdt_setprop(vms->fdt, nodename, "cap-mmc-highspeed", NULL, 0);
+            qemu_fdt_setprop(vms->fdt, nodename, "mmc-hs200-1_8v", NULL, 0);
+        }
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "max-frequency", 200000000);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "cdns,phy-input-delay-sd-default", 8);
+		qemu_fdt_setprop_cell(vms->fdt, nodename, "cdns,phy-input-delay-mmc-highspeed", 3);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "cdns,phy-input-delay-mmc-ddr", 3);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "cdns,phy-dll-delay-strobe", 33);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "cdns,phy-dll-delay-sdclk", 45);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "cdns,phy-dll-delay-sdclk-hsmmc", 45);
+
+        base -= size;
+        irq -= 2;
+    }
+}
+
+static void fdt_add_flash_node(const HobotVersalVirt *vms, int flash)
+{
+    hwaddr flashsize = base_memmap[flash].size / 2;
+    hwaddr flashbase = base_memmap[flash].base;
+    char *nodename;
+
+    /* Report both flash devices as a single node in the DT */
+    nodename = g_strdup_printf("/soc/flash@%" PRIx64, flashbase);
+    qemu_fdt_add_subnode(vms->fdt, nodename);
+    qemu_fdt_setprop_string(vms->fdt, nodename, "compatible", "cfi-flash");
+    qemu_fdt_setprop_sized_cells(vms->fdt, nodename, "reg",
+                                    2, flashbase, 2, flashsize,
+                                    2, flashbase + flashsize, 2, flashsize);
+    qemu_fdt_setprop_cell(vms->fdt, nodename, "bank-width", 4);
+    g_free(nodename);
+}
+
+static void fdt_add_uart_nodes(const HobotVersalVirt *vms, int uart)
+{
+    char *nodename;
+    uint32_t nr_uart = ARRAY_SIZE(vms->soc.apu.peri.uarts);
+    hwaddr base = base_memmap[uart].base;
+    hwaddr size = base_memmap[uart].size;
+    int irq = a78irqmap[uart];
+    const char compat[] = "ns16550";
+    const char clocknames[] = "apb_pclk";
+    int i;
+
+    /* Create nodes in incremental address */
+    base = base + size * (nr_uart - 1);
+    irq = irq + nr_uart - 1;
+    for (i = nr_uart - 1; i >= 0; i--) {
+        nodename = g_strdup_printf("/soc/serial@%" PRIx64, base);
+        qemu_fdt_add_subnode(vms->fdt, nodename);
+        /* Note that we can't use setprop_string because of the embedded NUL */
+        qemu_fdt_setprop(vms->fdt, nodename, "compatible",
+                            compat, sizeof(compat));
+        qemu_fdt_setprop_sized_cells(vms->fdt, nodename, "reg",
+                                        2, base, 2, size);
+        qemu_fdt_setprop_cells(vms->fdt, nodename, "interrupts",
+                                GIC_FDT_IRQ_TYPE_SPI, irq,
+                                GIC_FDT_IRQ_FLAGS_LEVEL_HI);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "current-speed", 115200);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "clock-frequency", 24000000);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "reg-io-width", 4);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "reg-shift", 2);
+        qemu_fdt_setprop_cell(vms->fdt, nodename, "clocks",
+                                   vms->clock_phandle);
+        qemu_fdt_setprop(vms->fdt, nodename, "clock-names",
+                             clocknames, sizeof(clocknames));
+        base -= size;
+        irq -= 1;
+        if (i == 0) {
+            /* Select UART0 as console  */
+            qemu_fdt_setprop_string(vms->fdt, "/chosen", "stdout-path", nodename);
+        }
+
+        g_free(nodename);
+    }
+}
+
+static void *hobot_versal_virt_dtb(const struct arm_boot_info *binfo, int *fdt_size)
+{
+    const HobotVersalVirt *board = container_of(binfo, HobotVersalVirt,
+                                                 bootinfo);
+
+    *fdt_size = board->fdt_size;
+    return board->fdt;
+}
+
+static void hobot_versal_virt_mach_done(Notifier *notifier, void *data)
+{
+    HobotVersalVirt *vms = container_of(notifier, HobotVersalVirt,
+                                         machine_done);
+    MachineState *ms = MACHINE(vms);
+    ARMCPU *cpu = ARM_CPU(first_cpu);
+    struct arm_boot_info *info = &vms->bootinfo;
+    AddressSpace *as = arm_boot_address_space(cpu, info);
+
+    if (arm_load_dtb(info->dtb_start, info, info->dtb_limit, as, ms) < 0) {
+        exit(1);
+    }
+}
+
+static void hobot_versal_virt_mach_init(MachineState *machine)
+{
+    HobotVersalVirt *vms = HOBOT_VERSAL_VIRT_MACHINE(machine);
+    MachineClass *mc = MACHINE_GET_CLASS(machine);
+
+    mc->possible_cpu_arch_ids(machine);
+
+    vms->psci_conduit = QEMU_PSCI_CONDUIT_SMC;
+
+    object_initialize_child(OBJECT(machine), "sigi-virt", &vms->soc,
+                            TYPE_SIGI_VIRT);
+    object_property_set_link(OBJECT(&vms->soc), "sigi-virt.ddr",
+                            OBJECT(machine->ram), &error_abort);
+
+    if (vms->cfg.has_emmc)
+        object_property_set_bool(OBJECT(&vms->soc), "has-emmc",
+                                vms->cfg.has_emmc, &error_abort);
+
+    if (vms->cfg.virt)
+        object_property_set_bool(OBJECT(&vms->soc), "virtualization",
+                                vms->cfg.virt, &error_abort);
+
+    if(vms->cfg.secure)
+        object_property_set_bool(OBJECT(&vms->soc), "secure",
+                                vms->cfg.secure, &error_abort);
+
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(&vms->soc), &error_fatal);
+
+    create_fdt(vms);
+    fdt_add_clk_nodes(vms);
+    fdt_add_cpu_nodes(vms);
+    fdt_add_gic_node(vms);
+    fdt_add_gic_its_node(vms);
+    fdt_add_timer_nodes(vms);
+    fdt_add_uart_nodes(vms, VIRT_UART);
+    fdt_add_gpio_nodes(vms, VIRT_GPIO);
+    fdt_add_pcie_node(vms, VIRT_PCIE_ECAM);
+    fdt_add_usb_nodes(vms);
+    fdt_add_sdhci_nodes(vms, VIRT_SDHCI);
+    fdt_add_flash_node(vms, VIRT_FLASH);
+    fdt_add_aliases_nodes(vms);
+
+    vms->bootinfo.ram_size = machine->ram_size;
+    vms->bootinfo.board_id = -1;
+    vms->bootinfo.loader_start = base_memmap[VIRT_MEM].base;
+    vms->bootinfo.get_dtb = hobot_versal_virt_dtb;
+    vms->bootinfo.skip_dtb_autoload = true;
+    vms->bootinfo.psci_conduit = vms->psci_conduit;
+    arm_load_kernel(ARM_CPU(first_cpu), machine, &vms->bootinfo);
+
+    vms->machine_done.notify = hobot_versal_virt_mach_done;
+    qemu_add_machine_init_done_notifier(&vms->machine_done);
+}
+
+static void hobot_versal_virt_mach_instance_init(Object *obj)
+{
+    HobotVersalVirt *vms = HOBOT_VERSAL_VIRT_MACHINE(obj);
+    MachineState *ms = MACHINE(vms);
+
+    ms->smp.cores = SIGI_VIRT_CLUSTER_SIZE;
+    ms->smp.clusters = SIGI_VIRT_NR_ACPUS % SIGI_VIRT_CLUSTER_SIZE;
+    ms->smp.clusters = ms->smp.clusters ? SIGI_VIRT_NR_ACPUS / SIGI_VIRT_CLUSTER_SIZE + 1 :
+                                          SIGI_VIRT_NR_ACPUS / SIGI_VIRT_CLUSTER_SIZE;
+}
+
+static void hobot_versal_virt_mach_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->desc = "Horizon Robotics Jounery Partition Development Board";
+    mc->init = hobot_versal_virt_mach_init;
+    mc->min_cpus = SIGI_VIRT_NR_ACPUS;
+    mc->max_cpus = 16;
+    mc->minimum_page_bits = 12;
+    mc->possible_cpu_arch_ids = virt_possible_cpu_arch_ids;
+    mc->default_cpus = SIGI_VIRT_NR_ACPUS;
+    mc->no_cdrom = 1;
+    mc->no_sdcard = 1;
+    mc->no_floppy = 1;
+    mc->block_default_type = IF_EMMC;
+    mc->default_ram_id = "sigi-virt.ddr";
+
+    object_class_property_add_bool(oc, "emmc", NULL,
+		            hobot_versal_virt_set_emmc);
+    object_class_property_add_bool(oc, "virt", NULL,
+		            hobot_versal_virt_set_virt);
+    object_class_property_add_bool(oc, "secure", NULL,
+		            hobot_versal_virt_set_secure);
+}
+
+static const TypeInfo hobot_versal_virt_mach_info = {
+    .name       = TYPE_HOBOT_VERSAL_VIRT_MACHINE,
+    .parent     = TYPE_MACHINE,
+    .class_init = hobot_versal_virt_mach_class_init,
+    .instance_init = hobot_versal_virt_mach_instance_init,
+    .instance_size = sizeof(HobotVersalVirt),
+};
+
+static void hobot_versal_virt_machine_init(void)
+{
+    type_register_static(&hobot_versal_virt_mach_info );
+}
+
+type_init(hobot_versal_virt_machine_init)
diff --git a/hw/arm/meson.build b/hw/arm/meson.build
index 7345ca4873..47d061ee2e 100644
--- a/hw/arm/meson.build
+++ b/hw/arm/meson.build
@@ -46,6 +46,7 @@ arm_ss.add(when: 'CONFIG_XLNX_ZYNQMP_ARM', if_true: files('xlnx-zynqmp.c', 'xlnx
 arm_ss.add(when: 'CONFIG_CORTEX_R52_VIRT', if_true: files('r52_virt.c', 'r52_machine.c'))
 arm_ss.add(when: 'CONFIG_XLNX_VERSAL', if_true: files('xlnx-versal.c', 'xlnx-versal-virt.c'))
 arm_ss.add(when: 'CONFIG_HOBOT_VIRT', if_true: files('versal-sigi.c', 'hobot-versal-virt.c'))
+arm_ss.add(when: 'CONFIG_HOBOT_VIRT', if_true: files('versal-sigi-partition.c', 'hobot-versal-virt-partition.c'))
 arm_ss.add(when: 'CONFIG_FSL_IMX25', if_true: files('fsl-imx25.c', 'imx25_pdk.c'))
 arm_ss.add(when: 'CONFIG_FSL_IMX31', if_true: files('fsl-imx31.c', 'kzm.c'))
 arm_ss.add(when: 'CONFIG_FSL_IMX6', if_true: files('fsl-imx6.c'))
diff --git a/hw/arm/versal-sigi-partition.c b/hw/arm/versal-sigi-partition.c
new file mode 100644
index 0000000000..43be259385
--- /dev/null
+++ b/hw/arm/versal-sigi-partition.c
@@ -0,0 +1,631 @@
+/*
+ * Horizon Robotics Jounery SoC emulation
+ *
+ * Copyright (C) 2023 Horizon Robotics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "qapi/error.h"
+#include "qemu/module.h"
+#include "hw/sysbus.h"
+#include "net/net.h"
+#include "qom/object.h"
+#include "sysemu/sysemu.h"
+#include "sysemu/kvm.h"
+#include "hw/arm/boot.h"
+#include "kvm_arm.h"
+#include "hw/misc/unimp.h"
+#include "hw/arm/versal-sigi-partition.h"
+#include "qemu/log.h"
+#include "hw/misc/unimp.h"
+#include "hw/nvme/nvme.h"
+#include "hw/gpio/dwapb_gpio.h"
+#include "sysemu/blockdev.h"
+
+#define SIGI_VIRT_PART_ACPU_TYPE ARM_CPU_TYPE_NAME("cortex-a78ae")
+
+static bool sigi_virt_get_virt(Object *obj, Error **errp)
+{
+    SigiVirtPartition *s = SIGI_VIRT_PART(obj);
+
+    return s->cfg.virt;
+}
+
+static void sigi_virt_set_virt(Object *obj, bool value, Error **errp)
+{
+    SigiVirtPartition *s = SIGI_VIRT_PART(obj);
+
+    s->cfg.virt = value;
+}
+
+static bool virt_get_secure(Object *obj, Error **errp)
+{
+    SigiVirtPartition *s = SIGI_VIRT_PART(obj);
+
+    return s->cfg.secure;
+}
+
+static void virt_set_secure(Object *obj, bool value, Error **errp)
+{
+    SigiVirtPartition *s = SIGI_VIRT_PART(obj);
+
+    s->cfg.secure = value;
+}
+
+static void create_gpio(SigiVirtPartition *s, int gpio)
+{
+    MemoryRegion *sysmem = get_system_memory();
+    int irq = a78irqmap[gpio];
+    hwaddr base = base_memmap[gpio].base;
+    hwaddr size = base_memmap[gpio].size;
+    DeviceState *gicdev = DEVICE(&s->apu.gic);
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(s->apu.peri.gpio); i++) {
+        DeviceState *dev;
+        MemoryRegion *mr;
+
+        object_initialize_child(OBJECT(s), "gpio[*]", &s->apu.peri.gpio[i],
+                                TYPE_DWAPB_GPIO);
+        dev = DEVICE(&s->apu.peri.gpio[i]);
+        dev->id = g_strdup_printf("gpio%d", i);
+        sysbus_realize(SYS_BUS_DEVICE(dev), &error_fatal);
+
+        mr = sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0);
+        memory_region_add_subregion(sysmem, base, mr);
+
+        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, qdev_get_gpio_in(gicdev, irq));
+
+        base += size;
+        irq += 1;
+    }
+}
+
+static void create_uart(SigiVirtPartition *s, int uart)
+{
+    MemoryRegion *sysmem = get_system_memory();
+    int irq = a78irqmap[uart];
+    hwaddr base = base_memmap[uart].base;
+    hwaddr size = base_memmap[uart].size;
+    DeviceState *gicdev = DEVICE(&s->apu.gic);
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(s->apu.peri.uarts); i++) {
+        char *name = g_strdup_printf("uart%d", i);
+        DeviceState *dev;
+        MemoryRegion *mr;
+
+        object_initialize_child(OBJECT(s), name, &s->apu.peri.uarts[i],
+                                TYPE_SERIAL_MM);
+        dev = DEVICE(&s->apu.peri.uarts[i]);
+        qdev_prop_set_uint8(dev, "regshift", 2);
+        qdev_prop_set_uint32(dev, "baudbase", 115200);
+        qdev_prop_set_uint8(dev, "endianness", DEVICE_LITTLE_ENDIAN);
+        qdev_prop_set_chr(dev, "chardev", serial_hd(i));
+        sysbus_realize(SYS_BUS_DEVICE(dev), &error_fatal);
+
+        mr = sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0);
+        memory_region_add_subregion(sysmem, base, mr);
+
+        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, qdev_get_gpio_in(gicdev, irq));
+
+        base += size;
+        irq += 1;
+        g_free(name);
+    }
+}
+
+static void create_usb(SigiVirtPartition *s, int usb)
+{
+    MemoryRegion *sysmem = get_system_memory();
+    int irq = a78irqmap[usb];
+    hwaddr base = base_memmap[usb].base;
+    DeviceState *gicdev = DEVICE(&s->apu.gic);
+    DeviceState *dev;
+    MemoryRegion *mr;
+    USBDWC3 *usbc;
+
+    object_initialize_child(OBJECT(s), "usb", &s->apu.peri.usb,
+                            TYPE_USB_DWC3);
+    usbc = &s->apu.peri.usb;
+    dev = DEVICE(usbc);
+
+    qdev_prop_set_uint32(dev, "intrs", 1);
+    qdev_prop_set_uint32(dev, "slots", 2);
+    sysbus_realize(SYS_BUS_DEVICE(dev), &error_fatal);
+
+    mr = sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0);
+    memory_region_add_subregion(sysmem, base, mr);
+
+    sysbus_connect_irq(SYS_BUS_DEVICE(&usbc->sysbus_xhci), 0,
+                            qdev_get_gpio_in(gicdev, irq));
+}
+
+static void create_emmc_card(CadenceSDHCIState *cdns, int index)
+{
+    DriveInfo *di = drive_get(IF_EMMC, 0, index);
+    BlockBackend *blk = di ? blk_by_legacy_dinfo(di) : NULL;
+    DeviceState *emmc;
+
+    emmc = qdev_new(TYPE_EMMC);
+    emmc->id = g_strdup_printf("emmc%d", index);
+    object_property_add_child(OBJECT(cdns), "emmc[*]", OBJECT(emmc));
+    object_property_set_uint(OBJECT(emmc), "spec_version", 3, &error_fatal);
+    object_property_set_uint(OBJECT(emmc), "boot-config", 0, &error_fatal);
+    qdev_prop_set_drive_err(emmc, "drive", blk, &error_fatal);
+    qdev_realize_and_unref(emmc, cdns->bus, &error_fatal);
+}
+
+static void create_sd_card(CadenceSDHCIState *cdns, int index)
+{
+    DriveInfo *di = drive_get(IF_SD, 0, index);
+    BlockBackend *blk = di ? blk_by_legacy_dinfo(di) : NULL;
+    DeviceState *card;
+
+    card = qdev_new(TYPE_SD_CARD);
+    card->id = g_strdup_printf("sd%d", index);
+    object_property_add_child(OBJECT(cdns), "card[*]", OBJECT(card));
+    qdev_prop_set_drive_err(card, "drive", blk, &error_fatal);
+    qdev_realize_and_unref(card, cdns->bus, &error_fatal);
+}
+
+static void create_sdhci(SigiVirtPartition *s, int sdhci)
+{
+    MemoryRegion *sysmem = get_system_memory();
+    int irq = a78irqmap[sdhci];
+    hwaddr base = base_memmap[sdhci].base;
+    hwaddr size = base_memmap[sdhci].size;
+    DeviceState *gicdev = DEVICE(&s->apu.gic);
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(s->apu.peri.mmc); i++) {
+        DeviceState *dev;
+        MemoryRegion *mr;
+        irq += i * 2;
+
+        object_initialize_child(OBJECT(s), "sdhci[*]", &s->apu.peri.mmc[i],
+                                TYPE_CADENCE_SDHCI);
+        dev = DEVICE(&s->apu.peri.mmc[i]);
+        dev->id = g_strdup_printf("sdhci%d", i);
+        object_property_set_uint(OBJECT(dev), "index", i,
+                                 &error_fatal);
+        object_property_set_uint(OBJECT(dev), "capareg", SDHCI_CAPABILITIES,
+                                 &error_fatal);
+
+        sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+
+        mr = sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0);
+        memory_region_add_subregion(sysmem,
+                                    base + i * size, mr);
+
+        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, qdev_get_gpio_in(gicdev, irq));
+    }
+}
+
+static void create_i2c(SigiVirtPartition *s, int i2c)
+{
+    MemoryRegion *sysmem = get_system_memory();
+    int irq = a78irqmap[i2c];
+    hwaddr base = base_memmap[i2c].base;
+    hwaddr size = base_memmap[i2c].size;
+    DeviceState *gicdev = DEVICE(&s->apu.gic);
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(s->apu.peri.i2c); i++) {
+        DeviceState *dev;
+        MemoryRegion *mr;
+
+        object_initialize_child(OBJECT(s), "i2c[*]", &s->apu.peri.i2c[i],
+                                TYPE_DWAPB_I2C);
+        dev = DEVICE(&s->apu.peri.i2c[i]);
+        dev->id = g_strdup_printf("i2c%d", i);
+        sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+        mr = sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0);
+        memory_region_add_subregion(sysmem, base, mr);
+
+        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, qdev_get_gpio_in(gicdev, irq));
+
+        base += size;
+        irq++;
+    }
+}
+
+static void create_its(SigiVirtPartition *s)
+{
+    const char *itsclass = its_class_name();
+    DeviceState *dev;
+
+    if (strcmp(itsclass, "arm-gicv3-its")) {
+            itsclass = NULL;
+    }
+
+    if (!itsclass) {
+        /* Do nothing if not supported */
+        return;
+    }
+
+    object_initialize_child(OBJECT(s), "gic-its", &s->apu.its, itsclass);
+    dev = DEVICE(&s->apu.its);
+
+    object_property_set_link(OBJECT(dev), "parent-gicv3", OBJECT(&s->apu.gic),
+                             &error_abort);
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, base_memmap[VIRT_GIC_ITS].base);
+}
+
+
+static void create_gic(SigiVirtPartition *s)
+{
+    MemoryRegion *sysmem = get_system_memory();
+    int nr_apu = ARRAY_SIZE(s->apu.cpus);
+    const char *gictype = gicv3_class_name();
+    /* We create a standalone GIC */
+    SysBusDevice *gicbusdev;
+    DeviceState *gicdev;
+    int i;
+
+    object_initialize_child(OBJECT(s), "apu-gic", &s->apu.gic, gictype);
+    gicdev = DEVICE(&s->apu.gic);
+    qdev_prop_set_uint32(gicdev, "revision", 3);
+    qdev_prop_set_uint32(gicdev, "num-cpu", nr_apu);
+    /* Note that the num-irq property counts both internal and external
+     * interrupts; there are always 32 of the former (mandated by GIC spec).
+     */
+    qdev_prop_set_uint32(gicdev, "num-irq",
+                            SIGI_VIRT_NUM_IRQS + 32);
+    qdev_prop_set_uint32(gicdev, "len-redist-region-count", 1);
+    qdev_prop_set_uint32(gicdev, "redist-region-count[0]", nr_apu);
+    qdev_prop_set_bit(gicdev, "has-lpi", true);
+    object_property_set_link(OBJECT(gicdev), "sysmem",
+                            OBJECT(sysmem), &error_fatal);
+
+    gicbusdev = SYS_BUS_DEVICE(gicdev);
+    sysbus_realize(gicbusdev, &error_fatal);
+    sysbus_mmio_map(gicbusdev, 0, base_memmap[VIRT_GIC_DIST].base);
+    sysbus_mmio_map(gicbusdev, 1, base_memmap[VIRT_GIC_REDIST].base);
+
+    /* Wire the outputs from each CPU's generic timer and the GICv3
+     * maintenance interrupt signal to the appropriate GIC PPI inputs,
+     * and the GIC's IRQ/FIQ/VIRQ/VFIQ interrupt outputs to the CPU's inputs.
+     */
+    for (i = 0; i < nr_apu; i++) {
+        DeviceState *cpudev = DEVICE(qemu_get_cpu(i));
+        int ppibase = SIGI_VIRT_NUM_IRQS + i * GIC_INTERNAL + GIC_NR_SGIS;
+        int irq;
+        /* Mapping from the output timer irq lines from the CPU to the
+         * GIC PPI inputs we use for the virt board.
+         */
+        const int timer_irq[] = {
+            [GTIMER_PHYS] = ARCH_TIMER_NS_EL1_IRQ,
+            [GTIMER_VIRT] = ARCH_TIMER_VIRT_IRQ,
+            [GTIMER_HYP]  = ARCH_TIMER_NS_EL2_IRQ,
+            [GTIMER_SEC]  = ARCH_TIMER_S_EL1_IRQ,
+        };
+
+        for (irq = 0; irq < ARRAY_SIZE(timer_irq); irq++) {
+            qdev_connect_gpio_out(cpudev, irq,
+                                  qdev_get_gpio_in(gicdev,
+                                                   ppibase + timer_irq[irq]));
+        }
+
+        qemu_irq irq_in = qdev_get_gpio_in(gicdev,
+                                            ppibase + ARCH_GIC_MAINT_IRQ);
+        qdev_connect_gpio_out_named(cpudev, "gicv3-maintenance-interrupt",
+                                        0, irq_in);
+
+        qdev_connect_gpio_out_named(cpudev, "pmu-interrupt", 0,
+                                    qdev_get_gpio_in(gicdev, ppibase
+                                                     + VIRTUAL_PMU_IRQ));
+
+        sysbus_connect_irq(gicbusdev, i, qdev_get_gpio_in(cpudev, ARM_CPU_IRQ));
+        sysbus_connect_irq(gicbusdev, i + nr_apu,
+                           qdev_get_gpio_in(cpudev, ARM_CPU_FIQ));
+        sysbus_connect_irq(gicbusdev, i + 2 * nr_apu,
+                           qdev_get_gpio_in(cpudev, ARM_CPU_VIRQ));
+        sysbus_connect_irq(gicbusdev, i + 3 * nr_apu,
+                           qdev_get_gpio_in(cpudev, ARM_CPU_VFIQ));
+    }
+
+    create_its(s);
+}
+
+static void create_pcie(SigiVirtPartition *s, int pcie)
+{
+    MemoryRegion *sysmem = get_system_memory();
+    DeviceState *gicdev = DEVICE(&s->apu.gic);
+    int irq = a78irqmap[pcie];
+    DeviceState *dev;
+    MemoryRegion *mmio_alias;
+    MemoryRegion *mmio_reg;
+    MemoryRegion *ecam_alias;
+    MemoryRegion *ecam_reg;
+    int i;
+
+    object_initialize_child(OBJECT(s), "pcie", &s->apu.peri.pcie,
+                                TYPE_GPEX_HOST);
+    dev = DEVICE(&s->apu.peri.pcie);
+    sysbus_realize(SYS_BUS_DEVICE(dev), &error_fatal);
+
+    /* Map only the first size_ecam bytes of ECAM space */
+    ecam_alias = g_new0(MemoryRegion, 1);
+    ecam_reg = sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0);
+    memory_region_init_alias(ecam_alias, OBJECT(dev), "pcie-ecam",
+                             ecam_reg, 0, base_memmap[VIRT_PCIE_ECAM].size);
+    memory_region_add_subregion(sysmem, base_memmap[VIRT_PCIE_ECAM].base,
+                                    ecam_alias);
+
+    /* Map the MMIO window into system address space so as to expose
+     * the section of PCI MMIO space which starts at the same base address
+     * (ie 1:1 mapping for that part of PCI MMIO space visible through
+     * the window).
+     */
+    mmio_alias = g_new0(MemoryRegion, 1);
+    mmio_reg = sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 1);
+    memory_region_init_alias(mmio_alias, OBJECT(dev), "pcie-mmio",
+                            mmio_reg, base_memmap[VIRT_PCIE_MMIO].base,
+                            base_memmap[VIRT_PCIE_MMIO].size);
+    memory_region_add_subregion(get_system_memory(), base_memmap[VIRT_PCIE_MMIO].base, mmio_alias);
+
+    /* Map high MMIO space */
+    MemoryRegion *high_mmio_alias = g_new0(MemoryRegion, 1);
+    memory_region_init_alias(high_mmio_alias, OBJECT(dev), "pcie-mmio-high",
+                            mmio_reg, base_memmap[VIRT_PCIE_MMIO_HIGH].base,
+                            base_memmap[VIRT_PCIE_MMIO_HIGH].size);
+    memory_region_add_subregion(get_system_memory(), base_memmap[VIRT_PCIE_MMIO_HIGH].base,
+                                high_mmio_alias);
+
+    for (i = 0; i < GPEX_NUM_IRQS; i++) {
+        sysbus_connect_irq(SYS_BUS_DEVICE(dev), i,
+                           qdev_get_gpio_in(gicdev, irq + i));
+        gpex_set_irq_num(GPEX_HOST(dev), i, irq + i);
+    }
+}
+
+static void create_apu(SigiVirtPartition *s)
+{
+    MemoryRegion *sysmem = get_system_memory();
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(s->apu.cpus); i++) {
+        Object *cpuobj;
+
+        object_initialize_child(OBJECT(s), "apu[*]", &s->apu.cpus[i],
+                                SIGI_VIRT_PART_ACPU_TYPE);
+        cpuobj = OBJECT(&s->apu.cpus[i]);
+        if (i) {
+            /* Secondary CPUs start in powered-down state */
+            object_property_set_bool(cpuobj, "start-powered-off", true,
+                                        &error_abort);
+        }
+
+        object_property_set_int(cpuobj, "mp-affinity",
+                                virt_cpu_mp_affinity(i), NULL);
+
+        if (!s->cfg.secure)
+            object_property_set_bool(cpuobj, "has_el3", false, NULL);
+
+        if (!s->cfg.virt)
+            object_property_set_bool(cpuobj, "has_el2", false, NULL);
+
+        object_property_set_bool(cpuobj, "pmu", false, NULL);
+
+        object_property_set_link(cpuobj, "memory", OBJECT(sysmem),
+                                    &error_abort);
+
+        qdev_realize(DEVICE(cpuobj), NULL, &error_fatal);
+    }
+}
+
+/* This takes the board allocated linear DDR memory and creates aliases
+ * for each split DDR range/aperture on the address map.
+ */
+static void create_ddr_memmap(SigiVirtPartition *s, int virt_mem)
+{
+    uint64_t cfg_ddr_size = memory_region_size(s->cfg.mr_ddr);
+    MemoryRegion *sysmem = get_system_memory();
+    hwaddr base = base_memmap[virt_mem].base;
+    hwaddr size = base_memmap[virt_mem].size;
+    hwaddr interleave_base = base_memmap[VIRT_INTERLEVEL_MEM].base;
+    uint64_t offset = 0;
+    char *name;
+    uint64_t mapsize;
+
+    mapsize = cfg_ddr_size < size ? cfg_ddr_size : size;
+    name = g_strdup_printf("sigi-ddr");
+    /* Create the MR alias.  */
+    memory_region_init_alias(&s->mr_non_interleave_ddr, OBJECT(s),
+                                name, s->cfg.mr_ddr,
+                                offset, mapsize);
+
+    name = g_strdup_printf("sigi-interleave-ddr");
+    memory_region_init_alias(&s->mr_interleave_ddr, OBJECT(s),
+                                name, s->cfg.mr_ddr,
+                                offset, mapsize);
+
+    /* Map it onto the main system MR.  */
+    memory_region_add_subregion(sysmem, base, &s->mr_non_interleave_ddr);
+    memory_region_add_subregion(sysmem, interleave_base, &s->mr_interleave_ddr);
+    g_free(name);
+
+    /* Create the On Chip Memory (L2SRAM).  */
+    memory_region_init_ram(&s->mr_l2sram, OBJECT(s), "l2sram",
+                           base_memmap[VIRT_L2SRAM].base, &error_fatal);
+    memory_region_add_subregion_overlap(sysmem, base_memmap[VIRT_L2SRAM].base, &s->mr_l2sram, 0);
+}
+
+static void create_unimp(SigiVirtPartition *s)
+{
+    create_unimplemented_device("peri-sysreg", 0x39010000, 0x10000);
+}
+
+static void create_pmu(SigiVirtPartition *s, int pmu)
+{
+    MemoryRegion *sysmem = get_system_memory();
+    hwaddr base = base_memmap[pmu].base;
+    DeviceState *dev;
+    MemoryRegion *mr;
+
+    object_initialize_child(OBJECT(s), "pmu", &s->pmu, TYPE_SIGI_PMU);
+
+    dev = DEVICE(&s->pmu);
+    object_property_set_link(OBJECT(dev), "shared-ocm", OBJECT(&s->mr_l2sram),
+                                    &error_abort);
+
+    sysbus_realize(SYS_BUS_DEVICE(dev), &error_fatal);
+    mr = sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0);
+    memory_region_add_subregion(sysmem, base, mr);
+}
+
+#define VIRT_FLASH_SECTOR_SIZE (256 * KiB)
+
+static PFlashCFI01 *virt_flash_create1(SigiVirtPartition *s,
+                                        const char *name,
+                                        const char *alias_prop_name)
+{
+    /*
+     * Create a single flash device.  We use the same parameters as
+     * the flash devices on the Versatile Express board.
+     */
+    DeviceState *dev = qdev_new(TYPE_PFLASH_CFI01);
+    //object_property_add_child(OBJECT(s), "flash[*]", OBJECT(dev));
+
+    qdev_prop_set_uint64(dev, "sector-length", VIRT_FLASH_SECTOR_SIZE);
+    qdev_prop_set_uint8(dev, "width", 4);
+    qdev_prop_set_uint8(dev, "device-width", 4);
+    qdev_prop_set_bit(dev, "big-endian", false);
+    qdev_prop_set_uint16(dev, "id0", 0x89);
+    qdev_prop_set_uint16(dev, "id1", 0x18);
+    qdev_prop_set_uint16(dev, "id2", 0x00);
+    qdev_prop_set_uint16(dev, "id3", 0x00);
+    qdev_prop_set_string(dev, "name", name);
+    object_property_add_child(OBJECT(s), name, OBJECT(dev));
+    object_property_add_alias(OBJECT(s), alias_prop_name,
+                              OBJECT(dev), "drive");
+    return PFLASH_CFI01(dev);
+}
+
+static void create_cfi_flash(SigiVirtPartition *s)
+{
+    s->flash[0] = virt_flash_create1(s, "virt.flash0", "pflash0");
+    s->flash[1] = virt_flash_create1(s, "virt.flash1", "pflash1");
+}
+
+static void virt_flash_map1(PFlashCFI01 *flash,
+                            hwaddr base, hwaddr size,
+                            MemoryRegion *sysmem)
+{
+    DeviceState *dev = DEVICE(flash);
+
+    assert(QEMU_IS_ALIGNED(size, VIRT_FLASH_SECTOR_SIZE));
+    assert(size / VIRT_FLASH_SECTOR_SIZE <= UINT32_MAX);
+    qdev_prop_set_uint32(dev, "num-blocks", size / VIRT_FLASH_SECTOR_SIZE);
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+
+    memory_region_add_subregion(sysmem, base,
+                                sysbus_mmio_get_region(SYS_BUS_DEVICE(dev),
+                                                       0));
+}
+
+static void create_flash_memmap(SigiVirtPartition *s)
+{
+    MemoryRegion *sysmem = get_system_memory();
+    /*
+     * Map two flash devices to fill the VIRT_FLASH space in the memmap.
+     * sysmem is the system memory space.
+     */
+    hwaddr flashsize = base_memmap[VIRT_FLASH].size / 2;
+    hwaddr flashbase = base_memmap[VIRT_FLASH].base;
+
+    virt_flash_map1(s->flash[0], flashbase, flashsize,
+                    sysmem);
+    virt_flash_map1(s->flash[1], flashbase + flashsize, flashsize,
+                    sysmem);
+}
+
+static void sigi_virt_realize(DeviceState *dev, Error **errp)
+{
+    SigiVirtPartition *s = SIGI_VIRT_PART(dev);
+    int i;
+
+    create_apu(s);
+    create_gic(s);
+    create_uart(s, VIRT_UART);
+    create_sdhci(s, VIRT_SDHCI);
+    create_gpio(s, VIRT_GPIO);
+    create_pcie(s, VIRT_PCIE_ECAM);
+    create_usb(s, VIRT_DWC_USB);
+    create_i2c(s, VIRT_I2C);
+    create_ddr_memmap(s, VIRT_MEM);
+    create_pmu(s, VIRT_PMU);
+    create_cfi_flash(s);
+    create_flash_memmap(s);
+    create_unimp(s);
+
+    for (i = 0; i < ARRAY_SIZE(s->apu.peri.mmc); i++) {
+        if (s->cfg.has_emmc && i == 0) {
+            create_emmc_card(&s->apu.peri.mmc[i], i);
+            continue;
+        }
+        create_sd_card(&s->apu.peri.mmc[i], i);
+    }
+}
+
+static Property sigi_virt_properties[] = {
+    DEFINE_PROP_LINK("sigi-virt.ddr", SigiVirtPartition, cfg.mr_ddr, TYPE_MEMORY_REGION,
+                     MemoryRegion *),
+    DEFINE_PROP_BOOL("has-emmc", SigiVirtPartition, cfg.has_emmc, false),
+    DEFINE_PROP_END_OF_LIST()
+};
+
+static void sigi_virt_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->realize = sigi_virt_realize;
+    device_class_set_props(dc, sigi_virt_properties);
+
+    object_class_property_add_bool(klass, "virtualization", sigi_virt_get_virt,
+                                   sigi_virt_set_virt);
+    object_class_property_set_description(klass, "virtualization",
+                                            "Set on/off to enable/disable emulating a "
+                                            "guest CPU which implements the ARM "
+                                            "Virtualization Extensions");
+    object_class_property_add_bool(klass, "secure", virt_get_secure,
+                                    virt_set_secure);
+    object_class_property_set_description(klass, "secure",
+                                            "Set on/off to enable/disable the ARM "
+                                            "Security Extensions (TrustZone)");
+}
+
+static void sigi_virt_init(Object *obj)
+{
+}
+
+static const TypeInfo sigi_soc_info = {
+    .name = TYPE_SIGI_VIRT_PART,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(SigiVirtPartition),
+    .instance_init = sigi_virt_init,
+    .class_init = sigi_virt_class_init,
+};
+
+static void sigi_soc_register_types(void)
+{
+    type_register_static(&sigi_soc_info);
+}
+
+type_init(sigi_soc_register_types);
diff --git a/include/hw/arm/versal-sigi-partition.h b/include/hw/arm/versal-sigi-partition.h
new file mode 100644
index 0000000000..3e2c191f49
--- /dev/null
+++ b/include/hw/arm/versal-sigi-partition.h
@@ -0,0 +1,170 @@
+/*
+ * Horizon Robotics Jounery SoC emulation
+ *
+ * Copyright (C) 2023 Horizon Robotics Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef HOBOT_SIGI_VIRT_H
+#define HOBOT_SIGI_VIRT_H
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "qemu/units.h"
+#include "hw/arm/boot.h"
+#include "hw/intc/arm_gicv3.h"
+#include "hw/intc/arm_gicv3_its_common.h"
+#include "qom/object.h"
+#include "hw/char/serial.h"
+#include "hw/sd/cadence_sdhci.h"
+#include "qemu/log.h"
+#include "exec/hwaddr.h"
+#include "target/arm/cpu.h"
+#include "hw/gpio/dwapb_gpio.h"
+#include "hw/pci-host/gpex.h"
+#include "hw/net/cadence_gem.h"
+#include "hw/register.h"
+#include "hw/usb/hcd-dwc3.h"
+#include "hw/i2c//dwapb_i2c.h"
+#include "hw/misc/hobot-sigi-pmu.h"
+#include "hw/block/flash.h"
+
+#define TYPE_SIGI_VIRT_PART "sigi-virt-partition"
+OBJECT_DECLARE_SIMPLE_TYPE(SigiVirtPartition, SIGI_VIRT_PART)
+
+#define SIGI_VIRT_CLUSTER_SIZE  4
+#define SIGI_VIRT_NR_ACPUS      6
+#define SIGI_VIRT_NR_RCPUS      4
+#define SIGI_VIRT_NR_UARTS      4
+#define SIGI_VIRT_NR_SDHCI      2
+#define SIGI_VIRT_NR_GPIO       2
+#define SIGI_VIRT_NR_I2C        4
+#define SIGI_VIRT_NUM_IRQS      960
+
+/* Cadence SDHCI capabilities register */
+#define SDHCI_CAPABILITIES  0x70156ac800UL
+
+#define ARCH_GIC_MAINT_IRQ  9
+
+#define ARCH_TIMER_VIRT_IRQ   11
+#define ARCH_TIMER_S_EL1_IRQ  13
+#define ARCH_TIMER_NS_EL1_IRQ 14
+#define ARCH_TIMER_NS_EL2_IRQ 10
+
+#define VIRTUAL_PMU_IRQ 7
+#define DDR_SIZE    (96UL * GiB)
+
+enum {
+    VIRT_MEM,
+    VIRT_FLASH,
+    VIRT_INTERLEVEL_MEM,
+    VIRT_GIC_DIST,
+    VIRT_GIC_ITS,
+    VIRT_GIC_REDIST,
+    VIRT_UART,
+    VIRT_SDHCI,
+    VIRT_GPIO,
+    VIRT_GEM,
+    VIRT_DWC_USB,
+    VIRT_USB_CTRL,
+    VIRT_PCIE_ECAM,
+    VIRT_PCIE_PIO,
+    VIRT_PCIE_MMIO,
+    VIRT_PCIE_MMIO_HIGH,
+    VIRT_L2SRAM,
+    VIRT_I2C,
+    VIRT_PMU,
+    VIRT_LOWMEMMAP_LAST,
+};
+
+static const MemMapEntry base_memmap[] = {
+    [VIRT_FLASH] =              { 0x18000000, 0x08000000 },
+    [VIRT_PMU] =                { 0x23190000, 0x00010000 },
+    [VIRT_GIC_ITS] =            { 0x30290000, 0x00010000 },
+    /* GIC distributor and CPU interfaces sit inside the CPU peripheral space */
+    [VIRT_GIC_DIST] =           { 0x30B00000, 0x00010000 },
+    /* This redistributor space allows up to 2 * 64kB * 14 CPUs */
+    [VIRT_GIC_REDIST] =         { 0x30B60000, 0x001C0000 },
+    [VIRT_GEM] =                { 0x33380000, 0x00010000 },
+    [VIRT_PCIE_ECAM] =          { 0x34000000, 0x00400000 },
+    [VIRT_PCIE_MMIO] =          { 0x80000000, 0x40000000 },
+    [VIRT_PCIE_MMIO_HIGH]=      { 0x8000000000, 0x8000000000 },
+    [VIRT_SDHCI] =              { 0x39030000, 0x00010000 },
+    [VIRT_UART] =               { 0x39050000, 0x00010000 },
+    /* ...repeating for a total of SIGI_VIRT_NR_UARTS, each of that size */
+    [VIRT_I2C] =                { 0x3A030000, 0x00010000 },
+    /* ...repeating for a total of SIGI_VIRT_NR_I2C, each of that size */
+    [VIRT_GPIO] =               { 0x3A120000, 0x00010000 },
+    [VIRT_USB_CTRL] =           { 0x3A000000, 0x00010000 },
+    [VIRT_DWC_USB] =            { 0x3A820000, 0x00010000 },
+    [VIRT_L2SRAM] =             { 0x04000000, 0x02000000 },
+    [VIRT_MEM] =                { 0x3000000000UL, DDR_SIZE },
+    [VIRT_INTERLEVEL_MEM] =     { 0x1000000000UL, DDR_SIZE },
+};
+
+static const int a78irqmap[] = {
+    [VIRT_UART] = 73,   /* ...to 73 + SIGI_VIRT_NR_UARTS - 1 */
+    [VIRT_SDHCI] = 120, /* ... 122 for SDHCI1 */
+    [VIRT_GPIO] = 78, /* ...to 78 + SIGI_VIRT_NR_GPIO - 1*/
+    [VIRT_PCIE_ECAM] = 127, /* ... to 130 */
+    [VIRT_GEM] = 40, /* ... to 41 */
+    [VIRT_DWC_USB] = 132,
+    [VIRT_I2C] = 101,   /* ... to 103 */
+};
+
+struct SigiVirtPartition {
+    /*< private >*/
+    SysBusDevice parent_obj;
+
+    /*< public >*/
+    struct {
+        struct {
+            SerialMM uarts[SIGI_VIRT_NR_UARTS];
+            CadenceSDHCIState mmc[SIGI_VIRT_NR_SDHCI];
+            DWAPBGPIOState gpio[SIGI_VIRT_NR_GPIO];
+            DWAPBI2CState i2c[SIGI_VIRT_NR_I2C];
+            GPEXHost pcie;
+            USBDWC3 usb;
+        } peri;
+
+        ARMCPU cpus[SIGI_VIRT_NR_ACPUS];
+        GICv3State gic;
+        GICv3ITSState its;
+    } apu;
+
+    SIGIPMUState pmu;
+    PFlashCFI01 *flash[2];
+
+    MemoryRegion mr_non_interleave_ddr;
+    MemoryRegion mr_interleave_ddr;
+    MemoryRegion mr_l2sram;
+
+    struct {
+        MemoryRegion *mr_ddr;
+        bool has_emmc;
+        bool virt;
+        bool secure;
+    } cfg;
+};
+
+static inline uint64_t virt_cpu_mp_affinity(int idx)
+{
+    uint64_t mp_aff = arm_cpu_mp_affinity(idx, SIGI_VIRT_CLUSTER_SIZE);
+
+    mp_aff <<= 8;
+    return mp_aff;
+}
+
+#endif
-- 
2.17.1

